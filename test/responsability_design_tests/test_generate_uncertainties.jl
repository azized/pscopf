using Test
using Dates
using JuMP

@testset verbose=true "generate_uncertainties" begin

    #=
    INPUT :
        Network := Electric grid description
        TS := target time steps (dates d'intÃ©rÃªt)
        ECH := list of horizon points as generated by the generate_ech responsibility
        NB_SCENARIOS := number of scenarios (or potentially, names of the scenarios)
        uncertainties_distribution (for each nodal injection)
    EXPECTED OUTPUT :
        For each nodal injection (load or limitable),
         At each horizon point (ech),
          At each timestep (ts),
           NB_SCENARIOS realisation of the uncertainty
    CARE POINTs:
        - generate_uncertainties assumes TS is sorted and unique ?
        - generate_uncertainties does not assume ECH is sorted nor unique ?
        - ECH can be nested ? -> allow using [generate_ech(grid, TS, PSCOPF_MODE_1), generate_ech(grid, TS, PSCOPF_MODE_2)]
        - generate_uncertainties should return sorted uncertainties by ech->name->ts->s ?
    =#
    @testset "one_mode" begin
        grid = create_grid(#=FIXME initial input or mocks=#)
        ts1 #=FIXME initial input or mocks=#
        TS = create_TS(Dates.DateTime(ts1)) #ts1 .+ [Dates.Minute(0), Dates.Minute(15), Dates.Minute(30), Dates.Minute(45)]
        ECH = generate_ech(grid, TS, PSCOPF_MODE_1)
        uncertainties_distribution #=FIXME=#
        NB_SCENARIOS #=FIXME=#

        uncertainties = generate_uncertainties(grid, TS, ECH, uncertainties_distribution, NB_SCENARIOSN)

        #FIXME : this is just the idea not necessarily in this order
        EXPECTED_NODAL_INJECTION_NAMES #=FIXME=#
        EXPECTED_SCENARIOS #=FIXME=#
        @test keys(uncertainties) == ECH
        for (ech, _) in uncertainties
            @test keys(uncertainties[ech]) == EXPECTED_NODAL_INJECTION_NAMES
            for (nodal_injection_name, _) in uncertainties[ech]
                @test keys(uncertainties[ech][nodal_injection_name]) == TS
                for ts in uncertainties[ech][nodal_injection_name]
                    @test length(uncertainties[ech][nodal_injection_name][ts]) == NB_SCENARIOS
                    @test keys(uncertainties[ech][nodal_injection_name][ts]) == EXPECTED_SCENARIOS
                    for (scenario, value_l) in uncertainties[ech][nodal_injection_name][ts]
                        @test value_l >= 0
                    end
                end
            end
        end
    end

    @testset "multiple_modes" begin
        grid = create_grid(#=FIXME initial input or mocks=#)
        ts1 #=FIXME initial input or mocks=#
        TS = create_TS(Dates.DateTime(ts1)) #ts1 .+ [Dates.Minute(0), Dates.Minute(15), Dates.Minute(30), Dates.Minute(45)]
        ECHs = [generate_ech(grid, TS, PSCOPF_MODE_1),
                generate_ech(grid, TS, PSCOPF_MODE_2),
                generate_ech(grid, TS, PSCOPF_MODE_3)]
        uncertainties_distribution #=FIXME=#
        NB_SCENARIOS #=FIXME=#

        uncertainties = generate_uncertainties(grid, TS, ECHs, uncertainties_distribution, NB_SCENARIOS)

        EXPECTED_ECH = sort(unique(Iterators.flatten(ECHs)))
        EXPECTED_NODAL_INJECTION_NAMES #=FIXME=#
        EXPECTED_SCENARIOS #=FIXME=#
        #FIXME : this is just the idea not necessarily in this order
        EXPECTED_NODAL_INJECTION_NAMES #=FIXME=#
        EXPECTED_SCENARIOS #=FIXME=#
        @test keys(uncertainties) == EXPECTED_ECH
        for (ech, _) in uncertainties
            @test keys(uncertainties[ech]) == EXPECTED_NODAL_INJECTION_NAMES
            for (nodal_injection_name, _) in uncertainties[ech]
                @test keys(uncertainties[ech][nodal_injection_name]) == TS
                for ts in uncertainties[ech][nodal_injection_name]
                    @test length(uncertainties[ech][nodal_injection_name][ts]) == NB_SCENARIOS
                    @test keys(uncertainties[ech][nodal_injection_name][ts]) == EXPECTED_SCENARIOS
                    for (scenario, value_l) in uncertainties[ech][nodal_injection_name][ts]
                        @test value_l >= 0
                    end
                end
            end
        end
    end

end